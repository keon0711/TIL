# 스프링 입문을 위한 객체지향의 원리와 이해
## static
- 클래스의 static 멤버는 프로그램이 실행될 때가 아니라, 클래스가 최초 사용될 때 static 메모리에 올라간다.

## 객체 메서드
- JVM에서는 객체 메서드를 객체 당 하나씩 만들지 않는다. 객체 메서드가 실행될 때마다 heap 영역에 메서드를 올리는 것이 아니라, static 영역에 메서드를 저장하고, 객체 메서드가 실행될 때마다 `this` 키워드로 객체 참조 변수를 인자로 넘긴다.
- JVM에 의해 아래와 같이 자신의 인스턴스를 매개변수로 가지는 메서드로 바뀐다고 생각할 수 있다.
```java
class Person {
	private String name;

	public void introduce(Person person) {
		System.out.println("저의 이름은 " + person.name + "입니다.")
	}
}
...
	Person p = new Person();
	Person.introduce(p)
```

## SOLID
### SRP 단일 책임 원칙
> 어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다.

- 클래스를 책임과 역할에 따라 적절히 분리해 하나의 역할과 책임만 갖게 해야한다.
- 메서드가 단일 책임 원칙을 지키지 않을 경우 나타나는 대표적인 냄새가 분기 처리를 위한 if 문이다.
- SRP와 가장 관계가 깊은 객체지향 특성은 **추상화**이다.

### OCP 개방 폐쇄 원칙
> 확장에는 열려 있어야 하지만, 변경에는 닫혀 있어야 한다.

### LSP 리스코프 치환 원칙
> 서브 타입은 언제나 자신의 기반 타입으로 교체할 수 있어야 한다.

LSP는 상속을 올바르게 사용하면 자연스럽게 만족하게 된다.  
상속은 계층도가 아니라 분류도가 되어야 한다.  
객체지향의 상속은 다음 두 문장을 만족해야 한다.
```
- 하위 클래스 is a kind of 상위 클래스
- 구현 클래스 is able to 인터페이스
```

### ISP 인터페이스 분리 원칙
> 클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안된다.

- 인터페이스를 통해 외부에는 최소한의 메서드만 제공해야 한다.

### DIP 의존 역전 원칙
> 고차원 모듈은 저차원 모듈에 의존하면 안된다. 이 두 모듈 모두 다른 추상화된 것에 의존해야 한다.
> 추상화된 것은 구체적인 것에 의존하면 안된다. 구체적인 것이 추상화된 것에 의존해야 한다.
> 자주 변경되는 구체 클래스에 의존하지 마라.

- 의존 역전 원칙을 의역하면 **자신보다 변하기 쉬운 것에 의존하지 마라**가 된다.
- 구체 클래스보다는 **상위 클래스, 추상 클래스,인터페이스** 에 의존하라