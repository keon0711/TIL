# 스프링 입문을 위한 객체지향의 원리와 이해
## JVM
### 정적(static) 멤버 저장 시점
- 클래스의 static 멤버는 프로그램이 실행될 때가 아니라, 클래스가 최초 사용될 때 static 메모리에 올라간다.

### 객체 메서드 저장 위치
- JVM에서는 객체 메서드를 객체 당 하나씩 만들지 않는다. 객체 메서드가 실행될 때마다 heap 영역에 메서드를 올리는 것이 아니라, static 영역에 메서드를 저장하고, 객체 메서드가 실행될 때마다 `this` 키워드로 객체 참조 변수를 인자로 넘긴다.
- JVM에 의해 아래와 같이 자신의 인스턴스를 매개변수로 가지는 메서드로 바뀐다고 생각할 수 있다.
```java
class Person {
	private String name;

	public void introduce(Person person) {
		System.out.println("저의 이름은 " + person.name + "입니다.")
	}
}
...
	Person p = new Person();
	Person.introduce(p)
```

## SOLID
### SRP 단일 책임 원칙
> 어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다.

- 클래스를 책임과 역할에 따라 적절히 분리해 하나의 역할과 책임만 갖게 해야한다.
- 메서드가 단일 책임 원칙을 지키지 않을 경우 나타나는 대표적인 냄새가 분기 처리를 위한 if 문이다.
- SRP와 가장 관계가 깊은 객체지향 특성은 **추상화**이다.

### OCP 개방 폐쇄 원칙
> 확장에는 열려 있어야 하지만, 변경에는 닫혀 있어야 한다.

### LSP 리스코프 치환 원칙
> 서브 타입은 언제나 자신의 기반 타입으로 교체할 수 있어야 한다.

LSP는 상속을 올바르게 사용하면 자연스럽게 만족하게 된다.  
상속은 계층도가 아니라 분류도가 되어야 한다.  
객체지향의 상속은 다음 두 문장을 만족해야 한다.
```
- 하위 클래스 is a kind of 상위 클래스
- 구현 클래스 is able to 인터페이스
```

### ISP 인터페이스 분리 원칙
> 클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안된다.

- 인터페이스를 통해 외부에는 최소한의 메서드만 제공해야 한다.

### DIP 의존 역전 원칙
> 고차원 모듈은 저차원 모듈에 의존하면 안된다. 이 두 모듈 모두 다른 추상화된 것에 의존해야 한다.
> 추상화된 것은 구체적인 것에 의존하면 안된다. 구체적인 것이 추상화된 것에 의존해야 한다.
> 자주 변경되는 구체 클래스에 의존하지 마라.

- 의존 역전 원칙을 의역하면 **자신보다 변하기 쉬운 것에 의존하지 마라**가 된다.
- 구체 클래스보다는 **상위 클래스, 추상 클래스,인터페이스** 에 의존하라

## 디자인 패턴
### Adapter Pattern
> "호출 당하는 쪽의 메서드를 호출하는 쪽의 코드에 대응하도록 중간에 변환기를 통해 호출하는 패턴"

- 어댑터 패턴은 **객체를 속성으로 만들어 참조**(합성)하는 패턴이다.

### Proxy Pattern
> 제어 흐름을 조정하기 위한 목적으로 중간에 대리자를 두는 패턴

- 프록시 객체는 실제 객체에 대한 참조 변수를 가진다. (합성)
- 프록시 객체는 **인터페이스를 사용**해 실제 객체와 같은 이름의 메서드를 구현한다. 
- 프록시 객체는 실제 서비스의 메서드 반환값을 가감하지 않고, 흐름을 제어하거나 다른 로직을 수행하기 위해 사용한다.
- OCP와 DIP가 적용된 설계 패턴

### Decorator Pattern
> 메서드 호출 반환값에 변화를 주기 위해 중간에 장식자를 두는 패턴

- 프록시 패턴과 구현 방법은 같지만, 실제 서비스의 반환값에 장식을 더한 결과를 클라이언트에 반환한다.

### Singleton Pattern
> 클래스의 인스턴스를 하나만 만들어 사용하는 패턴

- 인스터스를 하나만 만들어 사용하기 위한 패턴
- new를 실행할 수 없도록 생성자에 `private` 접근 제어자로 지정
- **유일한 단일 객체를 생성할 수 있는 정적 메서드**가 필요하다.
- **유일한 단일 객체를 참조할 정적 참조 변수**가 필요하다.
- 단일 객체는 공유 객체로 사용되기 때문에 쓰기 가능한 속성을 가지면 안된다.
- 읽기 전용 속성이나 다른 단일 객체에 대한 참조를 가지는 것은 괜찮다.

```java
public class Singleton {  
	// 유일한 인스턴스
    private static Singleton singletonObject;  

	// private 생성자
    private Singleton() {}  
  
    public static Singleton getInstance() {  
	    // 인스턴스가 존재하지 않으면 생성
        if (singletonObject == null) {  
            return singletonObject = new Singleton();  
        }  

		// 유일한 인스턴스를 반환
        return singletonObject;  
    }  
}
```

### Template Method Pattern
> 상위 클래스의 템플릿 메서드에서 하위 클래스에서 오버라이딩한 메서드를 호출하는 패천

- 상위 클래스에 템플릿 메서드를 정의하고, 하위 클래스에서 추상 메서드를 오버라이딩해서 사용하는 패턴
- 중복되는 부분을 템플릿 메서드로 정의하고, 다른 부분은 하위 클래스가 직접 정의해 사용할 수 있다.
- 상위 클래스에 훅(Hook) 메서드를 두어 선택적으로 오버라이딩 할 수도 있다.

```java
public abstract class SuperClass {  
    public void templateMethod() {  
        System.out.println("안녕하세요");  
        printName();  
        System.out.println("입니다.");  
    }  
  
    // 하위 클래스가 오버라이해서 사용하는 추상 메서드  
    protected abstract void printName();  
}

public class SubClass1 extends SuperClass {  
    @Override  
    protected void printName() {  
        System.out.println("홍길동");  
    }  
}
```


### Factory Method Pattern
> 오버라이드된 메서드가 객체를 반환하는 패턴

- 팩터리 메서드는 객체를 반환하는 메서드이다.
- 메서드를 오버라이딩해서 상황에 맞는 객체를 얻을 수 있다.
- DIP를 활용한다.

### Strategy Pattern
> 클라이언트가 전략을 생성해 컨텍스트에 전략을 주입하는 패턴

- 전략 패턴을 구성하는 3가지 요소
	1. 전략 메서드를 가진 전략 객체
	2. 전략 객체를 사용하는 컨텍스트
	3. 전략 객체를 생성해 컨텍스트에 주입하는 클라이언트
- 템플릿 메서드 패턴과 유사하지만, 템플릿 메서드 패턴은 상속을 이용하고 전략 패턴은 객체 주입을 이용한다.
- 주입받은 전략 객체에 따라 메서드 실행 결과가 달라진다.
- 클라이언트가 적절한 객체를 주입해 컨텍스트를 유연하고, 확장성있게 사용할 수 있다.
- OCP와 DIP가 적용된 패턴이다.

```java
void runContext(Strategy strategy) {
	...
	strategy.runStrategy();
	...
}
```

### Template Callback Pattern
> 전략을 익명 내부 클래스로 구현한 패턴

- 전략 패턴의 변형으로 스프링 DI에서 사용하는 패턴
- 전략 패턴과 동일한데, 전략을 익명 내부 클래스로 정의해서 사용한다.
- 전략을 생성하는 코드가 중복된다면, 전략을 생성하는 부분을 컨텍스트 내부로 이동해 리팩터링할 수 있다.
- OCP와 DIP이 적용된 패턴이다.

