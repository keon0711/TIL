# 정수를 비트로 표현하는 방법
## LSB, MSB
#### Least Significant Bit
- 가장 작은 유효 비트
- 가장 오른쪽 비트
#### Most Significant Bit
- 가장 큰 유효 비트
- 가장 왼쪽 비트

## 2진수 덧셈
#### A+B
- 올림: A AND B
- 두 비트의 합: A XOR B
#### 오버플로
- MSB에서 올림이 발생함을 의미
#### 언더플로
- MSB 위쪽에서 1을 빌려오는 것을 의미

## 음수 표현
#### 부호와 크기 표현법
- MSB로 부호를 나타내고, 나머지 비트로 수의 절대값을 나타내는 방법
- 문제점 2가지
	- +0과 -0이 중복으로 비용이 낭비됨
	- **XOR과 AND를 통한 덧셈이 불가능**
#### 1의 보수
- 양수의 모든 비트를 뒤집어 음수를 표현하는 방법 (ex. 1 = 0001, -1 = 1110)
- 문제점 2가지
	- +0과 -0이 중복으로 낭비됨 (+0 = 0000, -0 = 1111)
	- 덧셈할 때 순환 올림이 발생해서 불편함 (MSB에서 발생한 올림은 LSB에 전달하는 것)
#### 2의 보수
- 1을 더했을 때 0이 나오는 값을 -1로 설정 ^635cc5
	- `0001 + x = 0000`인 x는 `1111`. 따라서 `-1 = 1111`로 설정
- 각 비트에 NOT 연산을 한 뒤 1을 추가하면 음수를 얻을 수 있다. 이때 MSB에서의 올림은 버린다.
- 4개 비트로 표현할 수 있는 값의 범위는 -8에서 7까지로 총 16개이다.

# 실수를 표현하는 방법
## 고정소수점 표현
- 소수점의 위치를 고정시켜 표현하는 방법
- 필요한 비트 개수가 너무 많아서 범용 컴퓨터에서는 잘 사용하지 않음
## 부동소수점 표현 (floating point)
- 소수점 왼쪽이 한 자리뿐인 소수(가수)와 지수로 표현하는 방법
- 문제점
	1. 하나의 값에 중복되는 비트 조합이 많다.
	2. 가능한 모든 수를 표현하지 못한다.
## IEEE 부동소수점 수 표준
- 부호부, 지수부, 가수부로 구성됨
- 가수의 맨 왼쪽 비트는 항상 1이기 때문에 생략한다.
- 지수부는 지수에 bias를 더해 구한다. (bias = 2^k-1, k = 지수부의 비트 수)

1. 기본 정밀도 부동소수점 수 (32bit)
	- 지수부 bias = 8
2. 2배 정밀도 부동소수점 수 (64bit)
	- 지수부 bias = 11
![_images/floating_point_10.png](https://codetorial.net/articles/_images/floating_point_10.png) 

# 비트 그룹의 이름
1. 니블: 4bit
2. 바이트: 8bit
3. 하프 워드: 16bit
4. 워드: 32bit
5. 더블 워드: 64bit

# 텍스트 표현
## 아스키 코드
- 정보 교환을 위한 미국 표준 코드
- 키보드에 있는 모든 기호에 7bit 수를 할당
- 통신 제어를 위한 ACK, NAK 등의 문자도 존재
## 유니코드 변환 형식 8비트 (UTF-8)
- 아스키가 아닌 문자를 처리하기 위한 인코딩 방식
- 아스키 문자를 8비트로 표현하기 때문에 아스키 데이터를 인코딩할 때는 추가 공간이 필요 없음
- 문자를 8비트 덩어리(octet)의 시퀀스로 인코딩



