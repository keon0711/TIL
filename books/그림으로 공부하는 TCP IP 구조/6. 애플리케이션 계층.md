# HTTP
## HTTP 버전
### HTTP/1.0 & HTTP/1.0
- 요청마다 TCP 커넥션을 만듬  

### HTTP/1.1
- 킵얼라이브: 한번 맺은 TCP 연결을 재사용
- 파이프라인: 응답을 기다리지 않고, 다음 요청을 보냄 ([HoL 블로킹](https://namu.wiki/w/HTTP/2#s-3.1)으로 예상과 달리 비효율적)  

### HTTP/2.0
- 텍스트 형식의 메시지 단위로 교환하는 애플리케이션 데이터를 **프레임** 단위로 교환
- **멀티플렉싱**: 1개의 TCP 커넥션 안에 **스트림**이라는 가상 채널을 만들어 스트림별로 요청과 응답을 교환
- **HPACK**: 메시지 헤더를 압축하는 기능
- **서버 푸시**: 최초의 요청을 해석해 다음에 올 요청을 예측해 미리 응답을 보내면, 수신측은 캐시에 저장  

### HTTP/3.0
- QUIC 기반
- 데이터를 보내지 않는 시간을 줄여 성능 향상
	- **UDP**를 사용한 지연 감소
	- **TLS 1.3**을 사용한 지연감소 (SSL 핸드셰이크)  


## HTTP/1.1의 메시지 포맷
- **HTTP 메시지**: HTTP에서 교환하는 정보
- HTTP 메시지에는 **리퀘스트 메시지**, **리스폰스 메시지** 2종류가 존재한다. 
### 메시지 포맷
	스타트 라인
	메시지 헤더
	-- 빈 줄 (r\n) --
	메시지 바디

### 리퀘스트 메시지 포맷
**리퀘스트 라인**, **메시지 헤더**, **메시지 바디**로 구성된다.

리퀘스트 메시지의 **메시지 헤더**는 **리퀘스트 헤더, 일반 헤더, 엔티티 헤더, 기타 헤더** 4개의 HTTP 헤더 중 하나로, 웹브라우저에 따라 다르다.   
각 헤더 필드는 `<헤더 이름>:<필드값>`으로 구성된다.

#### 리퀘스트 라인
**리퀘스트 라인**은 **메서드**, **리퀘스트 URI**, **HTTP 버전** 3가지로 구성된다.
##### 메서드
GET, POST, PUT, DELETE 등 리퀘스트 종류를 나타낸다.
##### 리퀘스트 URI(Uniform Resource Identifier)
리소스를 식별하기 위해 사용하는 문자열
URI 포맷에는 **절대 URI**와 **상대 URI**가 있다.
##### HTTP 버전
HTTP 버전을 나타낸다.

### 리스폰스 메시지 포맷
리스폰스 메시지는 **스테이터스 라인**, **메시지 헤더**, **메시지 바디** 3가지로 구성되어 있다.
#### 스테이터스 라인
웹 서버가 웹 브라우저에 대해 처리 결과를 반환하는 행
**HTTP 버전**, **스테이터스 코드**, **리즌 프레이즈**로 구성되어 있다.



## 다양한 HTTP 헤더
메시지 헤더는 **리퀘스트 헤더, 리스폰스 헤더, 일반 헤더, 엔티티 헤더, 기타 헤더** 5종류의 조합으로 구성된다.
### 리퀘스트 헤더
- **Accept 헤더**: 브라우저가 처리할 수 있는 파일 종류와 우선도를 전달
- **Host 헤더**(필수 헤더): 리퀘스트하는 웹서버의 **도메인 이름**과 **포트 번호**가 설정
- **Reference 헤더**: 직전 연결 소스의 URI (링크를 클릭할 때의 URI)
- **User-Agent 헤더**: 웹브라우저나 OS 등 사용자 환경을 나타내는 헤더
### 리스폰스 헤더
- **ETag 헤더**: 웹서버가 가진 파일 등의 리소스를 유일하게 식별하기 위한 헤더
- **Location 헤더**: 리다이렉트 위치를 알리기 위해 사용하는 헤더
- **Server 헤더**: 웹서버의 정보가 설정되어 있는 헤더 (웹서버 OS, 버전, 소프트웨어 등)
### 일반 헤더 (범용 헤더)
- **Cache-Control 헤더**: 브라우저나 서버의 캐시를 제어하기 위해 사용하는 헤더
	- 프라이빗 캐시: 브라우저에 저장되는 캐시
	- 공유 캐시: 프록시 서버나 CDN의 에지 서버에 저장되는 캐시
- **Connection 헤더 / Keep-Alive 헤더**: 킵얼라이브를 제어하는 헤더
### 엔티티 헤더 (메시지 바디 관련 제어 정보)
- **Content-Encoding 헤더 / Accept-Encoding 헤더**
	  :웹브라우저가 처리할 수 있는 메시지 바디 압축 방식을 지정
- **Content-Length 헤더**: 메시지 바디 길이 (TCP를 언제 끊어야 할지를 알려줌)
### 기타 헤더
- **Set-Cookie**: 서버가 세션 관리에 사용하는 세션 ID나 사용자 개별 설정등을 웹 브라우저로 전송
- **Cookie**: 웹브라우저가 Set-Cookie를 통해 주어진 Cookie정보를 서버에 전송
- **X-Forwarded-For / X-Forwarded-Proto**: 부하 분산 장치 사용시 정보를 저장


## HTTP/2의 메시지 포맷
HTTP/2는 HTTP/1.1의 기본 요소나 역할은 유지하면서, **교환 형식을 바꿈으로써 전송 효율을 향샹**한 것이다.
### 리퀘스트 라인 / 스테이터스 라인
HTTP/2에서는 **리퀘스트 라인**과 **스테이터스 라인**의 구성요소를 **헤더로 취급**.  
#### 리퀘스트 라인 변화
![[Pasted image 20240108191527.png]]
#### 스테이터스 라인 변화
![[Pasted image 20240108193216.png]]

### 프로토콜 업그레이드
HTTP/1.x를 HTTP/2로 연결하기 위해서는 연결 상황에 따라 몇 가지 순서를 거쳐야 한다.
SSL 헨드셰이크 패턴, HTTP 헤더 패턴, 다이렉트 연결 패턴 3가지 패턴이 있다.
#### SSL 헨드셰이크 패턴
- SSL 헨드셰이크: SSL/TLS로 암호화 통신 전 수행하는 사전 준비
- ALPN이라는 확장 기능을 사용해 HTTP/2에 대응되는 것을 전달
#### HTTP 헤더 패턴
- 웹브라우저는 GET 요청을 할 때 Upgrade 헤더를 붙여 전달 (HTTP/2에도 대응한다는 의미)
- 웹서버도 HTTP/2에 대응한다면, Upgrade 헤더를 붙여 '101 Switching Protocol' 스테이터스 코드를 반환
- 웹서버가 먼저 Upgrade 헤더를 붙여 제안하는 경우도 존재
#### 다이렉트 연결 패턴
- 미리 서버가 HTTP/2에 대응한다는 걸 안다면 준비과정 없이 바로 HTTP/2로 연결 가능

## 부하 분산 장치의 동작
### 수신지 NAT
부하 분산 장치는 클라이언트로부터 패킷을 받으면 서버의 상태를 확인해 최적의 서버 IP 주소로 수신지 IP를 변환한다.
수신지 NAT은 **커넥션 테이블** 정보를 기반으로 수행한다.
### 부하 분산 방식
#### 정적 부하방식
- 라운드 로빈 방식
- 비율 방식
#### 동적 부하방식
- 최소 커넥션 수
- 최단 응답 시간


# SSL/TLS
HTTPS는 HTTP를 SSL로 암호화한 프로토콜
**암호화**, **해시화**, **디지털 인증서**라는 3가지 기술을 조합해 보안 위협에 대항한다.

### SSL 암호화 방식 (하이브리드 암호화 방식)
SSL은 대칭키와 비대칭키 암호화를 조합해서 사용하는 하이브리드 암호화 방식을 사용

먼저 공개키 암호화 방식으로 공통키 재료를 공유한다.
이후 주고받은 재료로 만든 공통키로 공통키 암호화을 사용한다.
공개키 방식으로 공통키를 안전하게 공유하고, 공개키 방식보다 속도도 빠르고 부하도 적다.

### SSL 해시 함수
SSL은 해시화를 통해 **애플리케이션 데이터 검증**, **디지털 인증서 검증**을 수행한다.

### SSL 흐름
1. 서버 인증서 준비
2. SSL 핸드 셰이크를 통한 사전 준비
3. 암호화 통신
4. SSL 세션 재이용
5. SSL 세션 종료

### 클라이언트 인증서
SSL은 서버 인증뿐 아니라 클라이언트 인증도 가능하다.
클라이언트 인증은 웹브라우저에 미리 설치한 **클라이언트 인증서**를 통해 클라이언트를 인증한다.



# DNS
IP 주소와 도메인 이름을 상호 교환하는 프로토콜이다.
## 도메인 이름
도메인 이름은 `www.google.com` 처럼 점으로 구분된 문자열로 구성된다.
호스트 부분과 도메인 부분으로 나뉜다.
- 호스트 부분은 가장 왼쪽에 있는 라벨로 컴퓨터 그 자체를 나타낸다 ('www')
- 도메인 부분은 오른쪽부터 탑 레벨 도메인, 세컨드 레벨 도메인, 서드 레벨 도메인으로 구성된다.
```
[www.example.co.kr.]
www: 호스트 이름
example: 서드 레벨 도메인
co: 세컨드 레벨 도메인
kr: 탑 레벨 도메인
.: 루트 (생략 가능) 
```

