# 2장 입출금 내역 분석기
## KISS 원칙
### final 변수
- final 변수를 사용하면 어떤 객체의 상태가 바뀔 수 있고, 어떤 객체의 상태가 바뀔 수 없는지 명확하게 구분할 수 있다.
- 그러나 final 키워드를 추가한다고 객체가 바뀌지 못하도록 강요하는 것은 아니다. final 필드로 가리키는 객체라도 가변 상태를 포함하기 때문이다.
- final은 재할당을 금지한다. 따라서 list.add 메서드 등을 사용하는 건 방지하지 못한다.

## 안티 패턴
### 갓 클래스
- 한 개의 파일에 모든 코드를 구현하다 보면 결국 하나의 거대한 클래스가 탄생하면서 클래스의 목적이 무엇인지 이해하기 어려워진다.
- 기존 코드의 로직을 갱신해야 할 때, 코드를 찾기 어려운 문제를 **갓 클래스 안티 패턴**이라고 한다.
### 코드 중복
- 코드를 간결하게 유지하는 것도 중요하지만 KISS 원칙을 남용해서는 안된다.
- 한 문제를 더 작은 개별 문제로 분리해 더 쉽게 관리할 수 있는지 파악해야 한다.

## 단일 책임 원칙(SRP)
다음 두 가지를 보완하기 위해 SRP를 적용한다.
- 한 클래스는 한 기능만 책임진다.
- 클래스가 바뀌어야 하는 이유는 오직 하나여야 한다.  

## 응집도
응집도는 **서로 어떻게 관련되어 있는지**를 가리킨다. 정확히 말하자면 응집도는 클래스나 메서드의 책임이 서로 얼마나 강하게 연결되어 있는지를 측정한다.
### 클래스 수준 응집도
실무에서는 일반적으로 다음과 같은 6가지 방법으로 그룹화한다.
그룹화하는 메서드의 관련성이 약하면 응집도가 낮아진다.
- 기능
	기능이 비슷한 메서드를 그룹화하는 방법
- 정보
	같은 데이터나 도메인 객체를 처리하는 메서드를 그룹화하는 방법 (DAO 등)
	필요한 일부 기능을 포함하는 클래스 전체를 디펜던시로 추가한다는 약점이 있다.
- 유틸리티
	메서드가 어디에 속해야할지 결정하기 어려울 때는 **유틸리티 클래스**에 추가하기도 한다.
	유틸리티 클래스 사용은 낮은 응집도로 이어지므로 자제해야 한다.
- 논리
	CSV, JSON, XML의 자료를 파싱하는 메서드를 한 클래스로 그룹화한다. 메서드들은 '파싱'이라는 논리로 그룹화된다.
	이렇게 그룹화하면 클래스는 네 가지 책임을 가지게 되므로 SRP를 위반한다.
	결론적으로 이 방법은 권장하지 않는다.
- 순차
	입출력이 순차적으로 흐르는 것을 순차 응집이라 부른다. SRP를 위반하므로 각 책임을 개별적으로 응집된 클래스로 분리하는 것이 더 좋은 방법이다.
- 시간
	시간에 관련된 연산을 그룹화한다. 
### 메서드 수준 응집도
메서드가 다양한 기능을 수행할 수록 메서드가 어떤 동작을 하는지 이해하기 어려워진다. 즉 메서드가 연관 없는 여러 일을 처리한다면 응집도가 낮아진다.
응집도가 낮은 메서드는 여러 책임을 포함하기 때문에 각 책임을 테스틀하기가 어렵고, 메서드의 책임도 테스트하기 어렵다.
일반적으로 클래스나 메서드 파라미터의 여러 필드를 바꾸는 if/else 블록이 여러 개 포함되어 있다면, 이는 응집도에 문제가 있음을 의미하므로, 응집도가 높은 더 작은 조각으로 메서드를 분리해야 한다.

## 결합도
결합도는 한 기능이 다른 클래스에 얼마나 의존하고 있는지를 가늠한다. 결합도는 어떤 클래스를 구현하는 데 얼마나 많은 지식(다른 클래스)를 참조했는가로 설명할 수 있다. 더 많은 클래스를 참조했다면 기능을 변경할 때 그만큼 유연성이 떨어진다.
결합도는 코드가 서로 **어떻게 의존하는지**와 관련이 있는 척도다.
인터페이스를 활용하면 요구사항이 바뀌더라도 유연성을 유지할 수 있다.
보통 코드를 구현할 때는 **결합도를 낮춰야한다**. 이는 코드의 다양한 컴포넌트가 내부와 세부 구현에 의존하지 않아야 함을 의미한다.

## 테스트
### 제이유닛 사용하기
유닛 테스트 설정의 세 단계 패턴을 **Given-When-Then** 공식이라 부른다.

### 코드 커버리지
코드 커버리지는 테스트 집합이 소프트웨어의 소스코드를 얼마나 테스트했는가를 가리키는 척도다. 보통 70~90퍼센트를 목표로 정할 것을 권한다.
코드 커버리지는 테스트하지 않은 부분이 남아 있음을 알려주는 역할에 지나지 않기 때문에 테스트 품질과는 아무 관련이 없다.
구문 커버리지 기법은 분기문을 한 구문으로 취급해버리는 약점이 있다. 따러서 구문 커버리지보다 각 분기문을 확인하는 분기 커버리지를 사용하는 것이 좋다.



# 3장 입출금 내역 분석기 확장판
두 가지 새로운 기능 요구사항
1. 특정 입출금 내역을 검색할 수 있는 기능. 예를 들어 주어진 날짜 범위 또는 특정 범주의 입출금 내역 얻기
2. 검색 결과의 요약 통계를 텍스트, HTML 등 다양한 형식으로 만들기

## 계방/폐쇄 원칙
> 개방/폐쇄 원칙: 기존의 코드를 변경하지 않으면서, 기능을 추가할 수 있도록 설계되어야 한다는 원칙

특정 금액을 검색하거나, 특정 월을 검색할 때마다 메소드를 복사해 `findTransactionsInMonthAndGreater()` 등 일일히 일일이 구현하는 것으로는 복잡한 요구사항을 만족시키기 어렵다.
이 방식에는 다음과 같은 한계가 있다.
- 거래 내역의 여러 속성을 조합할수록 코드가 복잡해진다.
- 반복 로직과 비즈니스 로직이 결합되어 있어 분리하기가 어렵다
- 코드를 반복한다.

개방/폐쇄 원칙을 적용하면 코드를 직접 바꾸지 않고 해당 메서드나 클래스의 동작을 바꿀 수 있다. 여기서는 Funtuinal interface를 만들어 문제를 해결한다. 

> 함수형 인터페이스: 한 개의 추상 메서드를 포함하는 인터페이스
> Predicate: 자바 8에서는 이와 같은 문제를 해결할 수 있는 Predicate\<T>라는 제네릭 인터페이스를 제공한다.

### 람다 표현식
새로운 요구사항이 있을 때마다 별도의 클래스를 만드는 것은 번거롭다. 자바 8부터는 람다 표현식을 사용할 수 있다.
```java
return findTransactions(bankTransaction -> bankTransaction.getDate().getMonth() == Month.FEBRUARY && bankTransaction.getAmount() >= 1000);
```

### 개방/폐쇄 원칙의 장점
- 기존 코드를 바꾸지 않으므로 기존 코드가 잘못될 가능성이 줄어든다.
- 코드가 중복되지 않으므로 기존 코드의 재사용성이 높아진다.
- 결합도가 낮아지므로 코드 유지보수성이 좋아진다.

## 명시적 API vs 암묵적 API
### 도메인 클래스 vs 원싯값
원싯값으로는 다양한 결과를 반환할 수 없어 유연성이 떨어진다. 따라서 도메인 클래스를 만들어 언제든 필요한 필드와 결과를 추가하도록 할 수 있다.



# 4장 문서 관리 시스템
## 요구사항
문서관리 시스템은 기존 환자 정보 파일을 읽어 색인을 추가하고 검색할 수 있는 형태의 정보로 변환해야 한다.
다음과 같은 세 가지 형식의 문서를 다룬다.
- 리포트: 환자의 수술과 상담 내용을 기록한 본문
- 우편물: 특정 주소로 발송되는 텍스트 문서
- 이미지: 치아와 잇몸 엑스레이 사진을 저장. 용량이 큼

각각의 문서는 관리 대상 파일의 경로와 어떤 환자의 기록물인지를 나타내는 정보도 포함해야 한다.

## 리스코프 치환 원칙 (LSP)
- 부모가 지정한 것보다 더 많은 선행조건을 요구할 수 없음
- 자식이 후행조건을 약화시킬 수 없음
- 부모 클래스에서 유지되는 모든 불변자는 자식 클래스에서도 유지되어야 한다.
- 자식 클래스는 부모가 허용하지 않은 상태 변화를 허용하지 않아야 한다.

## 기존 코드 확장과 재사용
### 3가지 방법
- 유틸리티 클래스 사용
- 상속 사용
- 도메인 클래스 사용

### 유틸리티 클래스 사용
유틸리티 클래스는 그럭저럭 쓸만하지만 객체지향 프로그래밍의 지향점과는 거리가 멀다.
유틸리티 클래스는 어떤 한 의무나 개념과 상관없는 다양한 코드의 모음으로 귀결된다. 시간이 흐를수록 갓 클래스의 모양을 갖춰간다.

### 상속 사용
일반적으로 상속 관계로 코드를 재사용하는 것은 좋은 방법이 아니다.
실제 관계를 제대로 반영하지 않은 상속은 쉽게 깨질 수 있다는 점이 문제다. 시간이 흐르고 응용프로그램이 바뀔 때, 응용프로그램을 그에 맞게 바꾸는 것보다는 **변화를 추상화**하는 것이 더 좋다.

### 도메인 클래스 구현
도메인 클래스를 사용하면 상속 같이 쉽게 깨질 수 있는 계층을 만들지 않으면서도 코드를 재사용할 수 있다.