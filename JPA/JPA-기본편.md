## 엔티티 매니저
- 엔티티 매니저 팩토리는 하나만 생성해서 애플리케이션 전체가 공유
- 엔티티 매니저는 고객의 요청이 올때마다 생성하고 종료해야 한다. (쓰레드 간 공유X)
- **JPA 모든 데이터 변경은 트랜젝션 안에서 실행해야한다.**

## 영속성 컨텍스트
- 엔티티를 영구 저장하는 환경
- 엔티티 매니저를 통해 영속성 컨텍스트에 접근

### 엔티티 생명 주기
1. 비영속 (`Member member = new Member()`)
2. 영속 (`em.persist(member)`)
3. 준영속 (`em.detatch(member)`)
4. 삭제 (`em.rmove(member)`)

### 영속성 컨텍스트의 이점
- 1차 캐시 (동일한 트랜잭션에서)
- 영속 엔티티의 동일성 보장
- 트랜잭션을 지원하는 쓰기 지연
- 변경 감지 (1차 캐시의 스냅샷과 비교해서 변경 여부를 감지)

## Flush
### 실행 방법
- em.flush()
- tx.commit()
- JPQL쿼리 실행

### 플러시 특성
- 영속성 컨텍스트를 비우지 않음 (`em.clear()`메서드로 지울 수 있음)
- 영속성 컨텍스트 변경 내용을 동기화

## 연관관계

### 다대일 연관관계
- N:1 관계에서 주인은 'N' 쪽이다. (외래키가 있는 테이블의 엔티티)
- `@JoinColumn(name = "{외래키 이름}")`애노테이션을 사용하는 쪽이 연관관계 주인이다.
- N:1 관계에서 '1' 쪽은 `@OneToMany(mappedBy = "{주인 클래스의 참조 변수명}")`로 정의한다.
- mappedBy라는 표현을 보면 수동적으로 매핑된다는 걸 알 수 있다.

- 양방향 매핑 시에는 순수 객체 상태를 고려해 양쪽에 값을 설정하는 것이 좋다.
- 영속성 컨텍스트의 1차 캐시에는 주인이 아닌 쪽의 값이 반영되지 않기 때문이다.
- 편의 메서드를 정의하면 편하게 양쪽 모두에 값을 설정할 수 있다.

### 일대다 연관관계
- 일대다는 지양하라
- 연관관계 주인은 N 쪽이 되는게 좋다. 따라서 일대다가 아니라 다대일 연관관계로 설계하는 것이 더 좋다.

### 다대다 연관관계
- N:M 연관관계는 `@ManyToMnay` 애노테이션으로 지원하지만 사용해서는 안된다.
- 중간 테이블에 해당하는 클래스를 만들고, `@ManyToMnay`대신 `@ManyToOne`과 `@OneToMnay`를 사용한다.


## 상속관계 매핑
- JPA가 상속관계를 처리하는 기본전략은 **단일 테이블 전략**이다.
- 상위 클래스에 `@Inheritance(strategy = ?)`로 상속관계 매핑 전략을 선택할 수 있다.
- `strategy = InheritanceType.JOINED`는 조인 전략을 의미한다.
- `@DiscriminatorColumn(name=“DTYPE”)`으로 식별 컬럼을 추가해주는 것이 좋다.

### 조인 전략
- 상위 클래스와 하위 클래스를 모두 만들고, 상위 클래스의 PK로 조인하는 전략
- 정규화되어 있어 저장공간을 효율적으로 사용한다.
- 외부 테이블이 참조할 때 상위 테이블만 조회하면 되기 때문에 효율적이다.
- 조회 쿼리가 복잡하고, 조인이 많아 성능 저하가 발생한다.

### 단일 테이블 전략
- 상위 테이블 하나에 하위 클래스의 모든 속성을 넣고, DTYPE 속성으로 어떤 하위 테이블인지 구분한다.

### 구현 클래스마다 테이블 전략
- 상위 클래스를 테이블로 만들지 않고, 하위 클래스에 상위 클래스 속성을 전부 넣어서 테이블을 만든다.
- `@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)`으로 설정한다.
- 상위 클래스 타입으로 조회할 때 하위 테이블을 전부 탐색해야 하기 때문에 성능상 문제가 있다.

## 공통 속성 상속
- `@MappedSuperclass` 애노테이션으로 모든 테이블에 공통으로 필요한 속성을 정의하고 필요한 엔티티에서 상속받아 사용할 수 있다..
- 추가한 사람,추가 시간, 수정시간 등 운영에 필요한 공통 속성들을 하나의 클래스에서 관리하고 싶을 때 사용한다.
- 엔티티가 아니기 때문에 테이블과 매핑되지 않는다.
- 직접 생성해 사용하지 않기 때문에 **추상 클래스**로 사용하는 것이 좋다.
- `@Entity` 클래스는 `@Entity`나 `@MappedSuperclass`만 상속할 수 있다.


## 프록시
### `em.find()` vs `em.getReference()`
- JPA는 데이터베이스 프록시 엔티티 객체 조회 기능을 지원한다.
- `em.find()`는 DB에서 실제 엔티티 객체를 조회해 가져온다.
- 반면 `em.getReference()`는 실제 엔티티가 아닌 프록시 객체를 가져온다.
- 프록시 객체는 실제 데이터가 필요한 순간 DB에 조회 쿼리를 날린다.

![[스크린샷 2024-01-20 오전 11.57.03.png]]

### 프록시 특징
프록시 객체는 처음 **한번만** 초기화한다. 초기화할 때 프록시 객체가 실제 엔티티로 바뀌는게 아니라, 프록시 객체를 통해 실제 엔티티에 접근할 수 있게된다.
프록시 객체는 원본 엔티티를 상속받는다. 따라서 프록시 객체를 비교할 때는 `==`가 아니라 `instance of`로 해야한다.