## 엔티티 매니저
- 엔티티 매니저 팩토리는 하나만 생성해서 애플리케이션 전체가 공유
- 엔티티 매니저는 고객의 요청이 올때마다 생성하고 종료해야 한다. (쓰레드 간 공유X)
- **JPA 모든 데이터 변경은 트랜젝션 안에서 실행해야한다.**

## 영속성 컨텍스트
- 엔티티를 영구 저장하는 환경
- 엔티티 매니저를 통해 영속성 컨텍스트에 접근

### 엔티티 생명 주기
1. 비영속 (`Member member = new Member()`)
2. 영속 (`em.persist(member)`)
3. 준영속 (`em.detatch(member)`)
4. 삭제 (`em.rmove(member)`)

### 영속성 컨텍스트의 이점
- 1차 캐시 (동일한 트랜잭션에서)
- 영속 엔티티의 동일성 보장
- 트랜잭션을 지원하는 쓰기 지연
- 변경 감지 (1차 캐시의 스냅샷과 비교해서 변경 여부를 감지)

## Flush
### 실행 방법
- em.flush()
- tx.commit()
- JPQL쿼리 실행

### 플러시 특성
- 영속성 컨텍스트를 비우지 않음 (`em.clear()`메서드로 지울 수 있음)
- 영속성 컨텍스트 변경 내용을 동기화

## 연관관계

### 다대일 연관관계
- N:1 관계에서 주인은 'N' 쪽이다. (외래키가 있는 테이블의 엔티티)
- `@JoinColumn(name = "{외래키 이름}")`애노테이션을 사용하는 쪽이 연관관계 주인이다.
- N:1 관계에서 '1' 쪽은 `@OneToMany(mappedBy = "{주인 클래스의 참조 변수명}")`로 정의한다.
- mappedBy라는 표현을 보면 수동적으로 매핑된다는 걸 알 수 있다.

- 양방향 매핑 시에는 순수 객체 상태를 고려해 양쪽에 값을 설정하는 것이 좋다.
- 영속성 컨텍스트의 1차 캐시에는 주인이 아닌 쪽의 값이 반영되지 않기 때문이다.
- 편의 메서드를 정의하면 편하게 양쪽 모두에 값을 설정할 수 있다.

### 일대다 연관관계
- 일대다는 지양하라
- 외래키가 다른 테이블에 존재하기 때문에 해당 테이블로 외래키를 업데이트하는 쿼리가 발생한다.
- 따라서 연관관계 주인은 N 쪽이 되는게 좋다. 일대다가 아니라 다대일 연관관계로 설계하는 걸 지향하자.

### 다대다 연관관계
- N:M 연관관계는 `@ManyToMnay` 애노테이션으로 지원하지만 사용해서는 안된다.
- 중간 테이블에 해당하는 클래스를 만들고, `@ManyToMnay`대신 `@ManyToOne`과 `@OneToMnay`를 사용한다.


## 상속관계 매핑
- JPA가 상속관계를 처리하는 기본전략은 **단일 테이블 전략**이다.
- 상위 클래스에 `@Inheritance(strategy = ?)`로 상속관계 매핑 전략을 선택할 수 있다.
- `strategy = InheritanceType.JOINED`는 조인 전략을 의미한다.
- `@DiscriminatorColumn(name=“DTYPE”)`으로 식별 컬럼을 추가해주는 것이 좋다.

### 조인 전략
- 상위 클래스와 하위 클래스를 모두 만들고, 상위 클래스의 PK로 조인하는 전략
- 정규화되어 있어 저장공간을 효율적으로 사용한다.
- 외부 테이블이 참조할 때 상위 테이블만 조회하면 되기 때문에 효율적이다.
- 조회 쿼리가 복잡하고, 조인이 많아 성능 저하가 발생한다.

### 단일 테이블 전략
- 상위 테이블 하나에 하위 클래스의 모든 속성을 넣고, DTYPE 속성으로 어떤 하위 테이블인지 구분한다.

### 구현 클래스마다 테이블 전략
- 상위 클래스를 테이블로 만들지 않고, 하위 클래스에 상위 클래스 속성을 전부 넣어서 테이블을 만든다.
- `@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)`으로 설정한다.
- 상위 클래스 타입으로 조회할 때 하위 테이블을 전부 탐색해야 하기 때문에 성능상 문제가 있다.

## 공통 속성 상속
- `@MappedSuperclass` 애노테이션으로 모든 테이블에 공통으로 필요한 속성을 정의하고 필요한 엔티티에서 상속받아 사용할 수 있다..
- 추가한 사람,추가 시간, 수정시간 등 운영에 필요한 공통 속성들을 하나의 클래스에서 관리하고 싶을 때 사용한다.
- 엔티티가 아니기 때문에 테이블과 매핑되지 않는다.
- 직접 생성해 사용하지 않기 때문에 **추상 클래스**로 사용하는 것이 좋다.
- `@Entity` 클래스는 `@Entity`나 `@MappedSuperclass`만 상속할 수 있다.


## 프록시
### `em.find()` vs `em.getReference()`
- JPA는 데이터베이스 프록시 엔티티 객체 조회 기능을 지원한다.
- `em.find()`는 DB에서 실제 엔티티 객체를 조회해 가져온다.
- 반면 `em.getReference()`는 실제 엔티티가 아닌 프록시 객체를 가져온다.
- 프록시 객체는 실제 데이터가 필요한 순간 DB에 조회 쿼리를 날린다.

![[스크린샷 2024-01-20 오전 11.57.03.png]]


### 프록시 특징
- 프록시 객체는 처음 **한번만** 초기화한다. 초기화할 때 프록시 객체가 실제 엔티티로 바뀌는게 아니라, 프록시 객체를 통해 실제 엔티티에 접근할 수 있게된다.
- 프록시 객체는 원본 엔티티를 상속받는다. 따라서 프록시 객체를 비교할 때는 `==`가 아니라 `instanceof`로 해야한다.
- 해당 엔티티가 이미 영속성 컨텍스트에 존재하면 `em.getReference()`를 호출해도 실제 엔티티가 반환된다. JPA는 같은 트랜잭션 안에서 엔티티 객체 동등성을 보장하기 때문이다.


## 지연 로딩
- 연관관계에 있는 엔티티가 있을 경우 DB에서 바로 조회해 실제 객체를 가져오지 않고, 프록시 객체를 가져온다.
- 참조하는 엔티티가 실제로 사용하는 시점에 초기화(DB에서 조회)한다.
- 참조하는 엔티티를 사용하지 않을 때에도 DB에서 조인하는 걸 방지한다.

## 즉시 로딩
- 즉시 로딩으로 연관관계에 있는 엔티티 객체를 한번에 가져올 수 있다.
- 연관관계가 강할 경우 즉시 로딩을 사용한다.
- 즉시 로딩을 사용하면 쿼리를 두번 나눠서 날리지 않고, 한번의 쿼리로 데이터를 가져올 수 있다.
- 실무에서 **즉시 로딩 사용을 지양**해야 한다.
	- JPQL에서 N+1 문제를 일으킨다.
	- 예상하지 못한 SQL이 발생한다.
- `@ManyToOne`, `@OneToOne`은 즉시 로딩이 기본 설정으로 되어있기 때문에 LAZY로 설정해줘야 한다.
- `@xxxToOne`일 경우에 즉시 로딩이 기본 설정이다. `@xxxToMany`가 즉시 로딩이면 조인이 많아져 문제가 생길 수 있기 때문인 것 같다. 
### N+1 문제
- 최초 쿼리 1개 때문에 N개의 쿼리가 추가로 나가는 문제

## 영속성 전이 (CASCADE)
- 연관관계가 있는 엔티티를 한번에 persist하고 싶을 때 사용한다.
- `@OneToMany(cascade = CascadeType.ALL)`와 같이 애노테이션의 속성을 선택할 수 있다.
- 반드시 참조되는 엔티티가 현재 엔티티에서만 참조할 때 사용해야 한다. 즉, **단일 소유자**일 때만 사용해야 한다.
- `CascadeType.ALL`: 라이프사이클을 동일하게
- `CascadeType.PERSIST`: persist만 동시에
## 고아 객체
- 고아 객체 자동 삭제 기능을 `orphanRemoval = true`로 사용할 수 있다.
- **단일 소유자**가 참조하는 엔티티 참조를 제거할 때, 자동으로 더 이상 참조되지 않는 엔티티(고아 객체)를 자동으로 삭제하는 쿼리를 날린다.
- 부모 객체를 제거하면 자식 객체도 더 이상 참조되지 않으므로 `cascade = CascadeType.REMOVE`처럼 동작한다.

## 값 타입
- 값 타입에는 **기본값 타입, 임베디드 타입, 콜렉션 값 타입**이 있다.
- 값 타입은 동등성 비교를 위해 equals 메서드를 재정의해야한다.
- 값 타입은 엔티티의 생명주기를 따르기 때문에 따로 persist 할 필요가 없다.
### 임베디드 타입
- 임베디드 타입을 사용하면 엔티티 클래스의 멤버로 클래스 참조변수를 가질 수 있다.
- 클래스를 정의할 때`@Embeddable`를, 클래스를 참조할 때는 `@Embedded` 애노테이션을 사용한다.
- DB 테이블에는 임베디드 타입의 멤버 필드가 속성으로 정의된다.
- 예를 들어 `int x; int y` 대신 `Point point`를 사용하면 엔티티 클래스에서는 Point 클래스로 관리할 수 있지만, 테이블에는 x, y가 속성으로 정의된다.
- 임베디드 타입도 엔티티와 연관관계를 맺을 수 있다.
- 임베디드 타입같은 값 타입을 여러 엔티티에서 공유하면 부작용이 발생할 수 있다. 따라서 값 타입은 **불변**으로 민들어야 한다.

### 값 타입 컬렉션
- DB에서 컬렉션을 처리하는 기능이 없기 때문에 값 타입 컬렉션은 해당 값 타입을 별도의 테이블로 만들어 관리한다.
- `@ElementCollection`, `@CollectionTable` 애노테이션을 사용한다.
- `@CollectionTable`로 테이블 이름, 외래키와 같은 매핑 정보를 넘긴다.
- 값 타입 컬렉션도 **지연로딩** 전략을 사용
- 값 타입 컬렉션에 변경사항이 생기면, **주인 엔티티와 연관된 모든 데이터를 삭제**하고, 값 타입 **컬렉션에 있는 현재 값을 모두 다시 저장**한다.
- 따라서 값 타입 컬렉션은 **사용을 지양**해야 한다.
- 값 타입 컬렉션 대신 **일대다 관계** 사용을 고려

## Reference
[김영한님 JPA 기본편](https://www.inflearn.com/course/ORM-JPA-Basic)


