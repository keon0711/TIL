# JVM
## 인터프리팅
- JVM 인터프리터는 평가 스택을 이용해 중간값들을 담아두고 가장 마지막에 실행된 명령어와 독립적으로 프로그램을 구성하는 opcode를 하나씩 순서대로 처리하는 'while 루프 안의 switch문 이다.'


## 클래스 로딩
- 자바 애플리케이션의 진입점인 `main()` 메서드에 진입하려면, 가상머신이 실행되기 전 클래스를 로드해야 한다.
- 제일 먼저 **부트스트랩 클래스**가 **자바 런타임코어 클래스**를 로드한다.
- 부트스트랩 클래스로더는 필수 클래스만 로드한다. (`java.lang.Object`)
- 이후 **확장 클래스로더**가 생긴다.
- 마지막으로 **애플리케이션 클래스로더**가 생성되고, **유저 클래스**를 로드한다.


## 바이트 코드 실행
- `javac`는 자바 소스 코드를 바이트코드로 가득찬 `.class`파일로 바꾼다.
- 바이트코드는 특정 컴퓨터 아키텍처에 특정하지 않은, 중간 표현형(IR) 이다.
- `javap -c HelloWorld` 명령으로 HelloWorld 클래스 파일을 들여다 볼 수 있다.


## JIT 컴파일 (Just In Time)
- 자바 프로그램은 바이트코드 인터프리터가 가상화한 스택 머신에서 명령어를 실행하며 시작된다.
- CPU를 추상화한 구조라 다양한 플랫폼에서 클래스 파일을 문제없이 실행할 수 있지만, 성능을 최대로 내기 위해서는 CPU에서 직접 프로그램을 실행시켜야 한다.
- 이를 위해 **핫스팟**은 프로그램 단위를 **바이트코드**에서 **네이티브 코드**로 컴파일한다.
- JIT 컴파일러는 인터프리티드 모드로 실행되는 동안 가장 자주 실행되는 코드 파트를 발견해 JIT 컴파일을 수행한다.
- 미리 프로그래밍한 추적 정보가 취합되면서 더 정교하게 최적화할 수 있다.
- JIT 컴파일러가 최적화를 하기 때문에, 컴파일 후 실행되는 코드는 원본 소스 코드와 전혀 다를 가능성이 크다.


## 스레딩과 자바 메모리 모델 (JMM)
- 주류 JVM 구현체에서 **자바 애플리케이션 스레드**는 각각 하나의 전용 **OS 스레드**에 대응된다.
- 자바 프로세스의 모든 스레드는 가비지가 수집되는 하나의 공용 힙을 가진다.
- 한 스레드가 생성한 객체는 그 객체를 참조하는 다른 스레드가 엑세스할 수 있다.
- 기본적으로 객체는 변경 가능하다. ㅡㅈㄱ, 객체 필드가 할당된 값은 `final` 키워드로 불변 표시하지 않는 한 바뀔 수 있다.