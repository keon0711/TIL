## 빈 스코프란?
스프링 빈은 기본적으로 싱글톤 스코프로 생성된다. 따라서 컨테이너 시작과 함께 생성된 후 컨테이너 종료될 때 소멸된다.
스프링은 싱글톤 외에도 다양한 스코프를 지원한다. **빈 스코프**는 빈이 존재할 수 있는 범위를 뜻한다.
- 싱글톤: 기본 스코프. 스프링 컨테이너 시작부터 종료까지 유진된다.
- 프로토타입: 스프링 컨테이너가 빈의 생성과 의존관계 주입까지만 관리한다.
- 웹 관련 스코프
	- request: 웹 요청이 들어오고 나갈 때까지 유지되는 스코프
	- session: 웹 세션이 생성되고 종료될때 까지 유지되는 스코프
	- application: 웹의 서블릿 컨텍스트와 같은 범위로 유지되는 스코프

`@Scope("prototype)"` 애노테이션으로 스코프를 지정한다.  
<br>
## 프로토타입 스코프
**스프링 컨테이너는 프로토타입 빈을 생성, 의존관계 주입, 초기화까지만 처리한다.**
클라이언트에 빈을 반환하고 나면 더 이상 빈을 관리하지 않는다.
### 특징
- 스프링 컨테이너에 요청할 때마다 새롭게 생성된다
- 스프링 컨테이너는 빈 생성, 의존관계 주입, 초기화까지만 관리한다
- 종료 메서드는 호출되지 않는다.
- 따라서 프로토타입 빈은 빈을 조회한 클라이언트가 직접 관리해야 한다. 종료 메서드도 클라이언트가 직접 호출해야 한다.

### 싱글톤 빈과 함께 사용시 문제점
싱글톤 빈에 프로토타입 빈을 주입할 때 스프링 컨테이너가 프로토타입 빈 생성한다. 싱글톤 빈이 프로토타입 빈을 사용할 때마다 새로운 빈을 생성하는 것은 아니다.
따라서 싱글톤 빈에서 요청할 때마다 새로운 프로토타입 빈을 생성하고 싶어도 이미 생성된 싱글톤 빈은 이미 생성된 동일한 프로토타입 빈을 참조한다.
==즉 싱글톤 빈에 프로토타입 빈을 주입할 때 새로운 프로토타입 빈을 생성해 주입할 뿐, 프로토타입 빈을 사용할 때마다 새로운 빈을 주입하는 것이 아니다!==

### 해결방법
`Provider`로 해당 문제를 해결할 수 있다.
의존관계를 외부에서 주입받는게 아니라 직접 필요한 의존관계를 찾는 것을 Dependency Lookup(DL) 의존관계 조회(탐색)이라고 한다.
이 DL 기능을 `Provider`가 제공한다.
```java
class ClientBean {  
    @Autowired  
    private ObjectProvider<PrototypeBean> prototypeBeanProvider;  
  
    public int logic() {  
        PrototypeBean prototypeBean = prototypeBeanProvider.getObject();  
        prototypeBean.addCount();  
        return prototypeBean.getCount();  
    }  
}
```
예제 코드와 같이 `ObjectProvider`을 사용해 DL 기능을 사용할 수 있다.
`Provider`는 `getObject()` 메서드를 호출할 때마다 `PrototypeBean`을 찾아서 반환해준다.

### 정리
- ==프로토타입 빈은 매번 사용할 때마다 의존관계 주입이 완료된 새로운 객체가 필요할 경우 사용한다.==
- 실무에서는 대부분 싱글톤을 사용하기 때문에 프로토타입 빈을 사용할 일은 드물다.
- `ObjectProvider`, `javax.inject.Provider<T>`는 프로토타입 뿐 아니라 DL이 필요한 경우 언제든 사용할 수 있다.
<br>

## 웹 스코프
### 웹 스코프 특징
- 웹 환경에서만 동작한다.
- 프로토타입과 달리 스프링이 해당 스코프의 종료시점까지 관리한다. 따라서 종료 메서드가 호출된다.
### 웹 스코프 종류
- **request**: HTTP 요청이 들어오고 나갈때까지 관리되는 스코프. 각각의 HTTP 요청마다 빈 인스턴스가 생성된다.
- **session**: HTTP session과 동일한 생명 주기를 가지는 스코프
- **application**: 서플릿 컨텍스트와 동일한 생명주기를 가지는 스코프
- **websocket**: 웹 소켓과 동일한 생명주기를 가지는 스코프
### request 스코프
- HTTP 요청이 들어오고, 나갈 때까지 관리되는 스코프
- 각각의 HTTP 요청마다 고유한 빈을 생성하고 싶을 때 사용한다.
- request 스코프를 사용하면 하나의 HTTP 요청에 대해 컨트롤러와 서비스에서 동일한 빈을 사용할 수 있다.
- 프로토타입과 마찬가지로 싱글톤 빈에 의존관계 주입시 request 빈은 존재하지 않기 때문에 Provider을 사용해 요청이 들어올 때마다 빈을 생성해야한다.
### 스코프와 프록시
프록시를 사용하면 `Provider`보다 더 간편하게 사용할 수 있다.
`@Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)`
- 적용 대상이 클래스면 `TARGET_CLASS`를 선택
- 적용 대상이 인터페이스면 `INTERFACES`를 선택

이렇게 하면 MyLogger의 가짜 프록시 클래스를 만들어두고 ==HTTP Request와 상관없이 가짜 프록시 클래스를 다른 빈에 미리 주입==해놓을 수 있다.
가짜 프록시 객체는 요청이 오면 그때 내부에서 진짜 빈을 요청하는 위임 로직이 들어있다.
가짜 프록시 객체는 request 스코프와 관련없이 싱글톤 스코프처럼 동작한다.

### 정리
- Provider나 Proxy나 핵심은 진짜 객체 조회를 꼭 필요한 시점까지 **지연처리**한다는 점이다.
