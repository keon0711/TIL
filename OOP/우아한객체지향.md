## 의존성 종류
- 연관관계: A에서 B로 이동가능 (객체 참조)
- 의존관계: 메소드 파라미터, 리턴타입이거나 메소드에서 인스턴스를 생성 (일시적)
- 상속관계
## 좋은 의존성 규칙
### 양방향 의존성을 피하라
#### 양방향
```java
class A {
	private B b;
}

class B {
	private A a;
}
```
#### 단방향
```java
class A {
	private B b;
}

class B {
}
```
### 다중성이 적은 방향을 선택하라
#### 다중연관관계
```java
class A {
	private Collection<B> bs;
}

class B {
}
```
#### 단일연관관계
```java
class A {
}

class B {
	private A a;
}
```
### 의존성이 필요 없다면 제거하라

## (문제점) 주문과 가게의 메뉴 불일치
### 관계의 방향 = 협력의 방향 = 의존성의 방향
### shop과 order 패키지가 서로 의존하는 관계 해결
- 중간 객체를 활용해 의존성 사이클 끊기

## 객체 참조의 문제점 
- 객체 참조는 결합도가 가장 높은 의존성
- 필요한 경우 객체 참조 끊기
### 해결 방법
- Repository를 통한 탐색 (약한 결합도)

## 어떤 객체들은 묶고, 어떤 객체들을 분리할 것인가
### 간단한 규칙
- 함께 생성되고, 함께 삭제되는 객체들을 묶어라
- 도메인 제약사항을 공유하는 객체들을 함께 묶어라
- ==가능하면 분리하라==


