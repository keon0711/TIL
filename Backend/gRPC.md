# gRPC

## gRPC란?
- **gRPC**는 Google이 개발한 **고성능 원격 프로시저 호출(Remote Procedure Call, RPC)** 프레임워크.
- 클라이언트와 서버 간 원격 메서드를 호출할 수 있도록 설계된 **오픈 소스 프레임워크**.
- 주로 **HTTP/2**를 기반으로 하며, 효율적인 바이너리 데이터 전송을 위해 **Protocol Buffers(proto)**를 사용.

---

## gRPC의 특징
1. **HTTP/2 기반**
   - 멀티플렉싱(다중 요청/응답 처리), 헤더 압축, 스트리밍 등 최신 HTTP/2 기능 활용.
   - 클라이언트와 서버 간 지속적이고 효율적인 통신 지원.

2. **Protocol Buffers 사용**
   - 가볍고 빠른 직렬화 도구.
   - JSON이나 XML 대비 **더 작은 데이터 크기와 빠른 처리 속도** 제공.

3. **다양한 통신 방식 지원**
   - **Unary RPC**: 클라이언트가 서버에 요청을 보내고, 서버가 단일 응답을 반환.
   - **Server-streaming RPC**: 클라이언트가 요청을 보내고, 서버가 스트리밍 형태로 여러 응답 반환.
   - **Client-streaming RPC**: 클라이언트가 스트리밍 데이터를 서버에 전송하고, 서버가 단일 응답 반환.
   - **Bidirectional-streaming RPC**: 클라이언트와 서버가 동시에 스트리밍 데이터를 주고받음.

4. **다중 언어 지원**
   - 다양한 언어(Java, C++, Python, Go 등)에서 사용할 수 있는 라이브러리 제공.

5. **서비스 정의**
   - 서비스는 `.proto` 파일에 정의되며, 이를 통해 클라이언트와 서버 간의 인터페이스를 명확히 정의.

---

## gRPC의 주요 장점
1. **고성능**
   - HTTP/2와 Protocol Buffers를 통해 높은 성능과 낮은 대기 시간을 제공.
   
2. **다양한 통신 패턴 지원**
   - 단일 요청-응답뿐만 아니라, 스트리밍 통신 패턴도 지원.

3. **다중 언어 지원**
   - 서버와 클라이언트가 서로 다른 언어로 구현되어도 상호 운영 가능.

4. **계층 구조 설계에 적합**
   - 마이크로서비스 아키텍처에서 서비스 간의 효율적인 통신을 지원.

5. **자동 코드 생성**
   - Protocol Buffers를 통해 인터페이스 정의를 기반으로 클라이언트 및 서버 코드 자동 생성.

---

## gRPC의 단점
1. **학습 곡선**
   - Protocol Buffers와 HTTP/2에 대한 이해가 필요.
   
2. **디버깅 어려움**
   - 바이너리 데이터 형식 때문에 JSON과 비교해 디버깅이 어려울 수 있음.

3. **브라우저 지원 부족**
   - 브라우저에서 직접 gRPC를 사용하는 데 제약이 있음. 이를 해결하기 위해 gRPC-Web이 제공되기도 함.

---

## gRPC의 주요 사용 사례
1. **마이크로서비스 간 통신**
   - 효율적이고 확장 가능한 서비스 간 데이터 교환.
   
2. **실시간 스트리밍**
   - 비디오, 오디오, 실시간 데이터 처리.

3. **IoT 및 모바일 애플리케이션**
   - 경량 데이터 전송 및 다중 클라이언트 지원.

4. **분산 시스템**
   - 분산 환경에서 높은 성능과 신뢰성을 요구하는 애플리케이션.

---

## gRPC와 REST API 비교

| **특징**            | **gRPC**                                | **REST API**                        |
|---------------------|-----------------------------------------|-------------------------------------|
| **프로토콜**        | HTTP/2                                  | HTTP/1.1                            |
| **데이터 포맷**     | Protocol Buffers (바이너리)             | JSON 또는 XML (텍스트 기반)          |
| **성능**            | 더 빠르고 효율적                        | 느림 (텍스트 처리, HTTP 헤더 중복)   |
| **스트리밍 지원**   | 네이티브 스트리밍 지원                  | 제한적 (HTTP/1.1에서는 비효율적)     |
| **언어 지원**       | 다중 언어 지원                          | 언어에 독립적                       |
| **디버깅**          | 어렵다 (바이너리 포맷)                  | 쉽다 (텍스트 기반)                  |
| **호환성**          | 클라이언트-서버가 같은 정의(proto) 공유 | 표준 HTTP 사용으로 호환성 높음      |

---

## gRPC의 구성 요소
1. **.proto 파일**
   - 서비스와 메시지 정의.
   - 예: 클라이언트 요청과 서버 응답 데이터 구조.

2. **Protocol Buffers**
   - 데이터를 직렬화하고 역직렬화하는 데 사용.

3. **클라이언트와 서버**
   - 클라이언트는 서버의 원격 메서드를 호출하고, 서버는 요청을 처리해 응답 반환.

---

## gRPC 동작 방식
1. **.proto 파일 작성**:
   - 클라이언트와 서버 간 통신을 위한 서비스와 메시지 구조 정의.

2. **코드 생성**:
   - gRPC 플러그인을 사용해 .proto 파일로부터 클라이언트 및 서버 코드 생성.

3. **클라이언트 요청**:
   - 클라이언트가 gRPC 메서드를 호출하며, Protocol Buffers를 사용해 데이터를 직렬화.

4. **서버 처리**:
   - 서버는 요청을 처리하고 Protocol Buffers로 직렬화된 응답을 클라이언트에 반환.

---

## gRPC 사용 시 고려 사항
1. **HTTP/2 지원**:
   - 서버와 네트워크가 HTTP/2를 지원해야 함.
   
2. **보안**:
   - TLS/SSL을 통해 안전한 데이터 전송 보장.

3. **프로토콜 설계**:
   - `.proto` 파일을 잘 설계해 데이터 구조와 서비스 인터페이스를 명확히 정의.

4. **디버깅 도구**:
   - gRPC는 바이너리 데이터 사용으로 디버깅이 어렵기 때문에 적절한 디버깅 도구 필요.

---

## 요약
- gRPC는 고성능, 효율적인 데이터 전송, 스트리밍 지원 등으로 현대 마이크로서비스 환경에 적합한 통신 프레임워크.
- Protocol Buffers와 HTTP/2를 기반으로 하여 REST보다 빠르고 데이터 전송량이 적음.
- 마이크로서비스, 스트리밍, IoT 같은 다양한 분야에서 강력한 선택지.